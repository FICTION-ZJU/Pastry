

# Pastry: The Positive Almost-Sure Termination Prototype

Pastry is an academic prototype for deciding (positive) almost-sure termination (PAST) of essentially 1-dimensional probabilistic counter programs (PCPs).
For more technical details, please refer to our CAV'25 paper:

> Sergei Novozhilov, Mingqi Yang, Mingshuai Chen, Zhiyang Li, Jianwei Yin:
On the Almost-Sure Termination of Probabilistic Counter Programs. In Proc. of CAV 2025.

This file contains instructions for the artifact evaluation of Pastry. In particular, we show how to reproduce the experimental results for Pastry and its competitors Amber, KoAT1, and KoAT2 as reported in Table 1 of the above paper and how to reuse Pastry beyond the paper, e.g., to run user-supplied examples.

## Contents
- [Project Structure](#project-structure)
- [Requirements](#requirements)
- [Setup](#setup)
- [Smoke test](#smoke-test)
- [Replicating the results from the paper](#replicating-the-results-from-the-paper)
- [Running Pastry on benchmarks](#running-pastry-on-benchmarks)
- [Writing your own example](#writing-your-own-example)
- [Running Pastry on your own example](#running-pastry-on-your-own-example)
- [Installing Pastry from Sources](#installing-pastry-from-sources)
- [Pastry Internals](#pastry-internals)
## Project structure
The structure of the artifact is as follows.

```
./artifact-main
├── baselines     # Baseline tools      
│   ├── amber     # Code and configuration for running Amber      
│   ├── KoAT1     # Code and configuration for running KoAT1
│   └── KoAT2     # Code and configuration for running KoAT2
├── benchmarks    # Benchmarks that are known out-of-reach by a tool are excluded from the corresponding directory
│   ├── pastry    # Benchmarks formatted for Pastry
│   ├── amber     # Benchmarks formatted for Amber
│   ├── KoAT1     # Benchmarks formatted for KoAT1
│   └── KoAT2     # Benchmarks formatted for KoAT2
├── outputs
│   └── logs      # Directory for storing all logs generated by Pastry
├── pastry        # Code and configuration of Pastry
│   ├── test      # Test programs used for smoke test
│   ├── src       # Core source code of Pastry 
│   └── ...
├── result        # Benchmark results
├── Dockerfile    # Docker image source
├── exec.sh       # Docker image wrapper to run Pastry on a single program
├── LICENSE.md    # MIT License
├── pastry.tar    # Docker image
├── README.md     # This file
├── run.py        # Helper script
└── run.sh        # Benchmarks runner script 
```

## Requirements
- Install Docker (https://www.docker.com/get-started/) in case you do not have it yet.
- Experiments in the paper are conducted on a 3.22 GHz Apple M1 Pro processor with 16GB RAM running macOS Sequoia. Make sure to have similar specs when comparing timing results and consider differences running in a sandbox (docker).



## Setup
Create a docker container from the provided tar file (which requires docker daemon running in the background):
```bash
docker load -i pastry.tar
```

## Smoke test

For a quick test to see if everything works:

```bash
docker run --platform linux/amd64 --rm --entrypoint bash pastry:latest pastry/batch_test.sh --input \
test/ast.txt \
test/past.txt \
test/none.txt
```

Expected output is: 
```
Running: test/ast.txt
PAST : False
AST  : True
Time : 0.097s
Running: test/past.txt
PAST : True
AST  : True
Time : 0.013s
Running: test/none.txt
PAST : False
AST  : False
Time : 0.01s
```


## Replicating the results from the paper

Reproduce the results in Table 1 (except for the column of Absynth, which has a separate artifact) by running the following command (which takes around 8 minutes):


```bash
docker run --platform linux/amd64 --rm -it -v "$(pwd)/outputs:/home/artifact/pastry/outputs" -v "$(pwd)/result:/home/artifact/result" --entrypoint bash pastry:latest run.sh --run-all -t 90
```
or on Windows PowerShell, run
```bash
docker run --platform linux/amd64 --rm -it -v "$(Get-Location)/outputs:/home/artifact/pastry/outputs" -v "$(Get-Location)/result:/home/artifact/result" --entrypoint bash pastry:latest run.sh --run-all -t 90
```

**The generated results** in CSV format can be found in `./result/all_experiment_data.csv`. The generated table matches (part of) Table 1 in the paper, except for formatting differences and host-dependent time variations. The table entries can be (1) a floating-point number representing running time in seconds (in case of success), (2) "-" when a tool does not support the corresponding benchmark, or (3) "TO" when the time limit (90 seconds) has been reached.

**Note:** The checkmarks and crossmarks in Table 1 are ground truth. One can verify these results by, e.g., running (only) Pastry on the benchmarks (see section below). For the specific benchmark 'geometric_gauss' beyond the reach of Pastry, one can run Amber via

```bash
docker run --platform linux/amd64 --rm -v "$(pwd)/outputs:/home/artifact/pastry/outputs" --entrypoint bash pastry:latest run.sh amber geometric_gauss
```
or on Windows PowerShell, run
```bash
docker run --platform linux/amd64 --rm -v "$(Get-Location)/outputs:/home/artifact/pastry/outputs" --entrypoint bash pastry:latest run.sh amber geometric_gauss
```

**The detailed logs** for Pastry are recorded in `./pastry/outputs/logs`. The logs contain reports for each step of the algorithm: preprocessing, special case recognition, transformation of inputs into a Probabilistic Transition System instance, finitization, labeling procedure, and conclusion of results.


## Running Pastry on benchmarks

To run only Pastry on the benchmarks, invoke on Unix-like systems:
```bash
docker run --platform linux/amd64 --rm -v "$(pwd)/outputs:/home/artifact/pastry/output" --entrypoint bash pastry:latest pastry/benchmark.sh
```
or on Windows PowerShell, run
```bash
docker run --platform linux/amd64 --rm -v "$(Get-Location)/outputs:/home/artifact/pastry/output" --entrypoint bash pastry:latest pastry/benchmark.sh
```

The results will be printed to the console. 

To run Pastry on a specific benchmark (for example, '2d_bounded_rw'):

```bash 
docker run --platform linux/amd64 --rm -v "$(pwd)/outputs:/home/artifact/pastry/outputs" --entrypoint bash pastry:latest run.sh pastry 2d_bounded_rw
```
or on Windows PowerShell:
```bash 
docker run --platform linux/amd64 --rm -v "$(Get-Location)/outputs:/home/artifact/pastry/outputs" --entrypoint bash pastry:latest run.sh pastry 2d_bounded_rw
```


## Writing your own example

This section describes the input language used by Pastry and explains how users can write and annotate their own probabilistic counter programs. Example programs are provided to illustrate the format.


### Syntax of PCPs


```
start: declarations instructions

declarations: declaration* -> declarations

declaration: "int" var "=" INT

instructions: instruction* -> instructions

instruction: "skip"                                 -> skip
            | "while" "(" guard ")" block           -> while
            | "if" "(" guard ")" block "else" block -> if
            | block "[" PROB "]" block              -> choice
            | var ":=" var "+" NAT                  -> inc_assign
            | var ":=" var "-" NAT                  -> dec_assign

block: "{" instruction* "}"

expression: var                                   -> var
            | INT                                 -> int
            | expression "+" expression           -> add
            | expression "-" expression           -> sub
            | expression "*" expression           -> mul
            | expression "**" NAT                 -> pow
            | "MOD" "(" expression "," POSINT ")" -> mod
            | "DIV" "(" expression "," POSINT ")" -> div

guard: "true"                                    -> true
        | "false"                                -> false
        | expression ">" expression              -> gt
        | expression "<" expression              -> lt
        | expression ">=" expression             -> ge
        | expression "<=" expression             -> le
        | "Eq" "(" expression "," expression ")" -> eq
        | "Ne" "(" expression "," expression ")" -> neq
        | "(" guard ")" "&" "(" guard ")"        -> and
        | "(" guard ")" "|" "(" guard ")"        -> or
        | "Not" "(" guard ")"                    -> not

literal: INT     -> int
        | NAT    -> nat         
        | POSINT -> pos_int      
        | PROB   -> prob         

var: CNAME
```


**Note:** Non-counting assignments like `var := c` are not allowed. Instead, use two consecutive counter-style loops to simulate it as
``` 
while (var < c) { var := var + 1 }
while (var > c) { var := var - 1 }
```

### Annotation rules
In addition to 1-d PCPs, Pastry admits four classes of $k$-d PCPs that are reducible to $1$-d PCPs while preserving their termination properties (see Section 5 of the paper). These four classes include (i) All But One Counters are Bounded; (ii) Monotone Counters; (iii) Conditionally Bounded Counters; and (iv) Constant Probability Programs. For Classes (ii) and (iv), Pastry supports automated checking of whether an input $k$-d PCP belongs to these categories and thus decides termination without any user hint. However, For Classes (i) and (iii), users need to provide correct annotations to assist the analysis：
- For *All But One Counters are Bounded PCPs*, users need to annotate the unbounded variable and the bounds (in the form of closed intervals) for the other variables at the top of the program using the following format:```/*@Bounded, <unbounded_var>, <var1>,[<lower>,<upper>], <var2>, [<lower>,<upper>], ...@*/```. If all variable are bounded, ```<unbounded_var>``` can be omitted from the annotation.
- For *Conditionally Bounded PCPs*, users need to provide valid constants (see Section 5 of the paper) at the top of the program using the following format: ```/*@CondBounded, y, x1[A1,B1,C1,D1], x2[A2,B2,C2,D2], ...@*/```

### Program examples

An example of $1$-d PCP:
```
# this is a comment
int x = 10
while(x**5 - 4*x**2 + x >= 0){
    if(x <= 1000){
        {x := x - 2}[1/2]{x := x + 1} 
    }else{
        {x := x - 1}[1/2]{x := x + 2} 
    }
}
```

An example of All But One Counters are Bounded PCP:
```
# this is a comment
/*@Bounded,i,[0,1],j,[0,2]@*/
int i = 0
int j = 0
while(i < 1){
    if(j < 2){
        i := i + 1
    }else{
        j := j - 2
    }
}
```

An example of Monotone PCP:
```
# this is a comment
int x = -3
int y = 0
while(x < 0){
    {x := x + 1}[1/10]{skip}
    while(y >= 1){
        {y := y - 1}[2/3]{y := y - 2}
    }
    y := y + 1
}
```

An example of Conditionally Bounded PCP:
```
# this is a comment
/*@CondBounded,y,x[1,1,0,1]@*/
int x = 1
int y = 1 
while(x + y >= 0){
    {x := x + 1; y := y + 1}[0.5]{x := x - 1; y := y - 1}
    if(Eq(x, y)){
        {y := y + 1}[0.5]{y := y - 1}
    }else{

    }
}
```

An example of Constant PCP:
```
# this is a comment
int T = 0
int H = 0
while(T - H > -1){
    {T := T + 1}[9/10]{H := H + 1}
}
```

More examples can be found in the benchmarks folder.


## Running Pastry on your own example

Suppose you have saved your example in a file named `path/to/a/program.txt`. Then Pastry can be invoked as


```bash
bash exec.sh path/to/a/program.txt
```

This will invoke the docker image and report the result.


## Installing Pastry from Sources 
Pastry can be installed from provided source files by following these steps:

1. Install the Poetry dependency management system:

```bash
curl -sSL https://install.python-poetry.org | python3 -
```
Then follow the installer instructions.

2. Install Pastry:

```bash
cd pastry && poetry install
```

3. To test the installation: 

```bash 
poetry run python3 pastry.py --input test/*
```
Expected ouput: 
```
Running: test/ast.txt
PAST : False
AST  : True
Time : 0.03s
Running: test/none.txt
PAST : False
AST  : False
Time : 0.011s
Running: test/past.txt
PAST : True
AST  : True
Time : 0.012s
```

To run Pastry on a program located at path/to/program.txt, run:
```bash 
poetry run python3 pastry.py --input path/to/program.txt
```

## Pastry Internals

Pastry closely follows the definitions and algorithms described in the paper "On the Almost-Sure Termination of Probabilistic Counter Programs", CAV'25. The following table gives the approximate correspondence between the paper and the Pastry source files:

| Paper | Pastry |
|-------|--------|
| Fig 1: 1-d PCP | `pastry/src/parsers/parser.py:parse_pcp` |
| Fig 1: 1-d PCTS | `pastry/src/models/pts.py:ProbabilisticTransitionSystem` |
| Fig 1: Infinite-State MC | `pastry/src/models/rmc.py:RegularMarkovChain` |
| Fig 1: Finite-State Labeled MC | `pastry/src/models/lmc.py:LabeledMarkovChain` |
| Fig 1: Decision | `pastry/src/models/lmc.py:LabeledMarkovChain.is_ast_and_past` |
| Algorithm 1: Deciding AST and PAST for 1-d PCPs | `pastry/pastry_core.py:run_core_analysis` |
| Algorithm 2: PCTS Decomposition into | `pastry/src/utils/project_utils.py:analyze_threshold_and_period_from_pts`, `pastry/pastry_core.py:run_core_analysis` |
| Algorithm 3: Identify the set of exit states at level-0 for each level-1 state | `pastry/src/models/rmc.py:RegularMarkovChain.get_boolean_reachability_matrix` |
| Algorithm 4: Label the coupled Markov chain | `pastry/src/lmc.py:RegularMarkovChain._get_bscc_category`, `pastry/src/lmc.py:RegularMarkovChain.get_level1_info` |
| Algorithm 5: Label the level-11 states of | `pastry/src/lmc.py:RegularMarkovChain.get_level1_info` |